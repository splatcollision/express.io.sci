// Generated by CoffeeScript 1.4.0
(function() {
  var RequestIO, RoomIO, async, connect, cookieParser, express, http, https, initRoutes, io, listen, middleware, session, sessionConfig, _;

  connect = require('express/node_modules/connect');

  express = require('express');

  cookieParser = require('cookie-parser');

  session = require('express-session');

  io = require('socket.io');

  http = require('http');

  https = require('https');

  async = require('async');

  middleware = require('./middleware');

  _ = require('underscore');

  RequestIO = require('./request').RequestIO;

  RoomIO = require('./room').RoomIO;

  express.io = io;

  express.io.routeForward = middleware.routeForward;

  sessionConfig = {
    name: 'connect.sid',
    store: new session.MemoryStore,
    cookie: new Object
  };

  express.application.http = function() {
    console.log('express.io.app.http creating server');
    this.server = http.createServer(this);
    return this;
  };

  express.application.https = function(options) {
    this.server = https.createServer(options, this);
    return this;
  };

  express.application.io = function(options) {
    var defaultOptions,
      _this = this;
    if (options == null) {
      options = new Object;
    }
    defaultOptions = {
      log: false
    };
    _.extend(options, defaultOptions);
    this.io = io(this.server, options);
    this.io.router = new Object;
    this.io.middleware = [];
    this.io.route = function(route, next, options) {
      var key, split, value, _results;
      if ((options != null ? options.trigger : void 0) === true) {
        if (route.indexOf(':' === -1)) {
          this.router[route](next);
        } else {
          split = route.split(':');
          this.router[split[0]][split[1]](next);
        }
      }
      if (_.isFunction(next)) {
        return this.router[route] = next;
      } else {
        _results = [];
        for (key in next) {
          value = next[key];
          _results.push(this.router["" + route + ":" + key] = value);
        }
        return _results;
      }
    };
    this.io.use(function(data, next) {
      var cookieParserInst;
      if (sessionConfig.store == null) {
        return async.forEachSeries(_this.io.middleware, function(callback, next) {
          return callback(data, next);
        }, function(error) {
          if (error != null) {
            return next(error);
          }
          return next(null, true);
        });
      }
      cookieParserInst = express.application.use(cookieParser());
      return cookieParserInst(data, null, function(error) {
        var rawCookie, request, sessionId;
        if (error != null) {
          return next(error);
        }
        rawCookie = data.cookies[sessionConfig.key];
        if (rawCookie == null) {
          request = {
            headers: {
              cookie: data.query.cookie
            }
          };
          return cookieParser(request, null, function(error) {
            var sessionId;
            data.cookies = request.cookies;
            rawCookie = data.cookies[sessionConfig.key];
            if (rawCookie == null) {
              return next("No cookie present", false);
            }
            sessionId = connect.utils.parseSignedCookie(rawCookie, sessionConfig.secret);
            data.sessionID = sessionId;
            return sessionConfig.store.get(sessionId, function(error, session) {
              if (error != null) {
                return next(error);
              }
              data.session = new connect.session.Session(data, session);
              return next(null, true);
            });
          });
        }
        sessionId = connect.utils.parseSignedCookie(rawCookie, sessionConfig.secret);
        data.sessionID = sessionId;
        return sessionConfig.store.get(sessionId, function(error, session) {
          if (error != null) {
            return next(error);
          }
          data.session = new connect.session.Session(data, session);
          return next(null, true);
        });
      });
    });
    this.io.use = function(callback) {
      return _this.io.middleware.push(callback);
    };
    this.io.sockets.on('connection', function(socket) {
      return initRoutes(socket, _this.io);
    });
    this.io.broadcast = function() {
      var args;
      args = Array.prototype.slice.call(arguments, 0);
      return _this.io.sockets.emit.apply(_this.io.sockets, args);
    };
    this.io.room = function(room) {
      return new RoomIO(room, _this.io.sockets);
    };
    this.use(function(request, response, next) {
      request.io = {
        route: function(route) {
          var ioRequest, key, value;
          ioRequest = new Object;
          for (key in request) {
            value = request[key];
            ioRequest[key] = value;
          }
          ioRequest.io = {
            broadcast: _this.io.broadcast,
            respond: function() {
              var args;
              args = Array.prototype.slice.call(arguments, 0);
              return response.json.apply(response, args);
            },
            route: function(route) {
              return _this.io.route(route, ioRequest, {
                trigger: true
              });
            },
            data: request.body
          };
          return _this.io.route(route, ioRequest, {
            trigger: true
          });
        },
        broadcast: _this.io.broadcast
      };
      return next();
    });
    return this;
  };

  listen = express.application.listen;

  express.application.listen = function() {
    var args;
    args = Array.prototype.slice.call(arguments, 0);
    if (this.server != null) {
      return this.server.listen.apply(this.server, args);
    } else {
      return listen.apply(this, args);
    }
  };

  initRoutes = function(socket, io) {
    var key, setRoute, value, _ref, _results;
    setRoute = function(key, callback) {
      return socket.on(key, function(data, respond) {
        var request, _base, _ref;
        if (typeof data === 'function') {
          respond = data;
          data = void 0;
        }
        request = {
          data: data,
          session: socket.handshake.session,
          sessionID: socket.handshake.sessionID,
          sessionStore: sessionConfig.store,
          socket: socket,
          headers: socket.handshake.headers,
          cookies: socket.handshake.cookies,
          handshake: socket.handshake
        };
        session = socket.handshake.session;
        if (session != null) {
          request.session = new connect.session.Session(request, session);
        }
        socket.handshake.session = request.session;
        request.io = new RequestIO(socket, request, io);
        request.io.respond = respond;
        if ((_ref = (_base = request.io).respond) == null) {
          _base.respond = function() {};
        }
        return callback(request);
      });
    };
    _ref = io.router;
    _results = [];
    for (key in _ref) {
      value = _ref[key];
      _results.push(setRoute(key, value));
    }
    return _results;
  };

  module.exports = express;

}).call(this);
